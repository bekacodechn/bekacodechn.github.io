# 2. 一般 HTML 性能注意事项


`metadata:`

**链接:** https://web.dev/learn/performance/general-html-performance

---

要建立一个加载速度快的网站，第一步就是要及时收到服务器对网页 HTML 的响应。在浏览器地址栏中输入 URL 时，浏览器会向服务器发送 [GET 请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)以获取该 URL。网页的第一个请求是获取 HTML 资源，而确保 HTML 能快速到达并将延迟降到最低是性能的关键目标。

最初的 HTML 请求需要经过几个步骤，每个步骤都需要一些时间。减少每个步骤所花费的时间，就能加快[首次字节加载时间（TTFB）](chrome/metrics/TTFB)。虽然 TTFB 并不是衡量网页加载速度的唯一标准，但如果 TTFB 过高，就很难达到指定的 "良好 "阈值，如[最大内容填充 (LCP)](chrome/metrics/LCP) 和[第一内容填充 (FCP)](https://web.dev/articles/fcp)。

:::info
注：有关如何优化网站 TTFB 的更多信息，请阅读优化 [TTFB 指南](https://web.dev/articles/optimize-ttfb)，因为有一些改进 TTFB 的技术不在本模块范围内。
:::

## 尽量减少重定向
当请求资源时，服务器可能会响应重定向，要么是永久重定向（301 Moved Permanently 响应），要么是临时重定向（302 Found 响应）。

重定向会降低页面加载速度，因为它要求浏览器在新位置发出额外的 HTTP 请求以检索资源。重定向有两种类型：

1. 同源重定向（Same-origin redirects）：完全发生在你的原点内。这类重定向完全在你的控制范围内，因为管理这些重定向的逻辑完全在你的网络服务器上。
2. 由另一个源发起的跨源重定向。这类重定向通常不受你的控制。

广告、URL 缩短服务和其他第三方服务经常使用跨源重定向。虽然跨源重定向不在您的控制范围内，但您可能仍要检查是否避免了多重重定向--例如，广告链接到 HTTP 页面，而 HTTP 页面又重定向到 HTTPS 页面，或者跨源重定向到达您的源，但又触发了同源重定向。

## 缓存 HTML 响应

缓存 HTML 响应非常困难，因为响应可能包含指向 CSS、JavaScript、图像和其他资源类型等其他重要资源的链接。这些资源可能在各自的文件名中包含一个[唯一的指纹](https://bundlers.tooling.report/hashing/)，该指纹会根据文件内容发生变化。这意味着您的缓存 HTML 文档在部署后可能会变得陈旧，因为它将包含对过时子资源的引用。(**这句话的意思是，在部署（发布）HTML文档后，由于HTML文档中包含对其他重要资源（如CSS、JavaScript、图像等）的引用，而这些资源可能会根据其文件内容发生变化，因此缓存的HTML文档可能会过时。换句话说，即使HTML文档本身没有更改，但由于所依赖的子资源发生了变化，缓存的HTML文档仍然会显示旧版本的子资源。这可能会导致网页在用户端显示不正确或功能不完整。为了避免这种情况，通常需要特殊处理缓存机制，以确保在更新子资源后也能正确获取最新的HTML文档。**)

:::info
一句话总结：`html`引用的资源名称中使用了`contentHash`，当资源发生变化时，虽然`html`本身没有变化，但也成了`陈旧`的缓存，要想办法解决这种问题。
:::

尽管如此，较短的缓存生命周期（而不是无缓存）还是有很多好处，比如可以在 CDN 上缓存资源，减少从源服务器提供的请求数量，还可以在浏览器中缓存资源，允许重新验证而不是再次下载。这种方法最适用于在任何情况下都不会改变的静态内容，缓存资源的适当时间可以设置为你认为合适的某个分钟数。对于静态 HTML 资源来说，`5 分钟`是一个安全的选择，可以确保定期更新不会被忽视。

如果页面的 HTML 内容是以某种方式个性化的，例如针对已通过身份验证的用户，那么出于安全和新鲜度等多方面的考虑，你很可能根本不想缓存内容。*如果用户的浏览器缓存了 HTML 响应，就无法使缓存失效。因此，在这种情况下最好完全避免缓存 HTML。*

缓存 HTML 的谨慎方法是使用 [ETag](https://developer.mozilla.org/docs/Web/HTTP/Headers/ETag) 或 [Last-Modified](https://developer.mozilla.org/docs/Web/HTTP/Headers/Last-Modified) 响应头。`ETag` 又称实体标记，是唯一代表所请求资源的标识符，通常使用资源内容的哈希值：

```json
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

只要资源发生变化，就必须生成新的 ETag 值。在后续请求中，浏览器通过 If-None-Match 请求头发送 ETag 值。如果服务器上的 ETag 与浏览器发送的相匹配，服务器就会回复 304 Not Modified（未修改），浏览器就会使用缓存中的资源。虽然这仍然会产生网络延迟，但 304 Not Modified 响应比整个 HTML 资源要小得多。

不过，重新验证资源新鲜度所涉及的网络延迟仍然是其自身的缺点。与网络开发的许多其他方面一样，权衡和妥协是不可避免的。您需要考虑的是，以这种方式缓存 HTML 所付出的额外努力是否值得，或者最好还是稳妥起见，完全不用缓存 HTML 内容。

:::info
注：`Last-Modified`（最后修改）标头的作用与此类似，它包括一个包含资源最后更新日期和时间的响应标头。
:::

[浏览器缓存演示及教程](https://learn-performance-caching.glitch.me/)

## 测量服务器响应时间

如果响应没有缓存，服务器的响应时间在很大程度上取决于托管服务提供商和后端应用程序。动态生成响应的网页（例如从数据库获取数据）的 TTFB 可能比静态网页的 TTFB 要高，因为静态网页可以立即提供服务，无需在后端花费大量计算时间。显示loading，然后在客户端获取所有数据，将工作从更可预测的服务器端环境转移到可能不可预测的客户端环境。最大限度地减少客户端的工作通常会提高以用户为中心的指标。

如果用户在现场遇到 TTFB 速度较慢的问题，可以通过使用服务器计时响应标头[Server-Timing response header](https://developer.mozilla.org/docs/Web/HTTP/Headers/Server-Timing)来显示服务器上花费时间的信息：

```json
Server-Timing: auth;dur=55.5, db;dur=220
```

`Server-Timing`标头的值可包括多个指标以及每个指标的持续时间。然后可以[使用导航定时 API 从现场用户那里](./navigation-and-resource-timing)收集这些数据，并对其进行分析，以确定用户是否遇到了延迟。在前面的代码片段中，响应标头包括两个计时：

- 用户身份验证时间 (auth)，耗时 55.5 毫秒。
- 数据库访问时间 (db)，耗时 220 毫秒。

:::info
注意：您可以在[优化 TTFB 指南](https://web.dev/articles/optimize-ttfb#understanding_high_ttfb_with_server_timing)中找到有关服务器计时响应标头的更多信息。
:::

您可能还需要检查您的主机基础设施，并确认您有足够的资源来处理网站接收的流量。共享主机提供商通常容易受到高 TTFB 的影响，而提供更快响应时间的专用解决方案可能成本更高。

:::info
您可以在 [ismyhostfastyet.com](https://ismyhostfastyet.com/)上比较热门托管服务提供商的 TTFB。该数据由 [Chrome 用户体验报告 (CrUX)](https://developer.chrome.com/docs/crux/) 数据集收集的真实用户体验组成。
:::


## 压缩
应压缩 HTML、JavaScript、CSS 和 SVG 图像等基于文本的响应，以减少它们在网络上的传输大小，从而更快地下载。最广泛使用的压缩算法是 gzip 和 Brotli。与 gzip 相比，Brotli 的压缩率提高了 15%-20%。

大多数虚拟主机提供商通常都会自动设置压缩，但如果要自己配置或调整压缩设置，也有一些重要事项需要考虑：

- **尽可能使用 Brotli。** 如前所述，Brotli 比 gzip 有相当明显的改进，而且所有主流浏览器都支持 Brotli。尽可能使用 Brotli，但如果使用传统浏览器的用户较多，请确保使用 gzip 作为备用，因为任何压缩都比不压缩要好。
- **文件大小很重要。** 非常小的资源（小于 1 KiB）不会被很好地压缩，有时甚至根本不会压缩。任何类型的数据压缩是否有效，取决于压缩算法是否能处理大量数据，以便找到更多可压缩的数据位。文件越大，压缩效果就越好，但不要仅仅因为可以更有效地压缩就将非常大的资源打包。大型资源（例如 JavaScript 和 CSS）在浏览器解压缩后需要花费更多时间进行解析和评估，而且即使变化不大，变化也可能更频繁，因为任何变化都会导致不同的文件哈希值。
- **了解动态压缩与静态压缩。** 动态压缩和静态压缩是对资源进行压缩的不同方法。动态压缩在资源被请求时对其进行压缩，有时甚至在每次请求时都进行压缩。另一方面，静态压缩会提前压缩文件，在请求时无需执行压缩。静态压缩消除了压缩本身的延迟，而动态压缩会增加服务器响应时间。静态资源（如 JavaScript、CSS 和 SVG 图像）应进行静态压缩，而 HTML 资源（尤其是为认证用户动态生成的资源）应进行动态压缩。

**自行正确压缩具有挑战性，通常最好让内容分发网络（CDN）为您处理**，下一节将讨论 CDN。不过，了解这些概念可以帮助你辨别托管服务提供商是否正确使用了压缩技术，也可以帮助你找到改进的机会。

## 内容分发网络（CDN）

[内容分发网络（CDN）](https://web.dev/articles/content-delivery-networks)是一个由服务器组成的分布式网络，这些服务器从您的源服务器缓存资源，然后再从离您的用户更近的边缘服务器提供服务。与用户的物理距离缩短了[往返延迟（RTT）](https://en.wikipedia.org/wiki/Round-trip_delay)，而 HTTP/2 或 HTTP/3、高速缓存和压缩等优化技术使 CDN 能够比从原始服务器获取内容更快地提供内容。在某些情况下，利用 CDN 可以显著改善网站的 TTFB。

:::info
注：如需深入了解 CDN 及其优势，请阅读 [CDN 指南](https://web.dev/articles/content-delivery-networks)。
:::

